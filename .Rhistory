library(pacman)
library(mgcv)
detach("package:mgcv", unload = TRUE)
detach("package:methods", unload = TRUE)
p_unload(all)
cat("\014")
cat("\014")
library(datasets)
head(iris)
?plot
?p_unpack
??p_unpack
plot(iris$Species)
plot(iris$Petal.Length)
plot(iris$Petal.Width)
plot(iris$Species,iris$Petal.Width)
plot(iris$Petal.Width,iris$Species)
plot(iris$Petal.Width,iris$Petal.Length)
plot (iris)
plot(iris$Petal.Length,iris&Petal.Width,)
plot(iris$Petal.Length,iris&Petal.Width,
col = "#cc0000",
pch = 19,
main = "iris petsjidojo",
xlab ="length",
ylab="width")
plot(iris$Petal.Length,irisPetal.Width,$
col = "#cc0000",
pch = 19,
main = "iris petsjidojo",
xlab ="length",
ylab="width")
plot(iris$Petal.Length,iris$Petal.Width,
col = "#cc0000",
pch = 19,
main = "iris petsjidojo",
xlab ="length",
ylab="width")
plot(iris$Petal.Length,iris$Petal.Width,
col = "#cc0000",
pch = 1,
main = "iris petsjidojo",
xlab ="length",
ylab="width")
plot(iris$Petal.Length,iris$Petal.Width,
col = "#cc0000",
pch = 5,
main = "iris petsjidojo",
xlab ="length",
ylab="width")
plot(iris$Petal.Length,irisPetal.Width,$
col = "#cc0000",
pch = 9,
main = "iris petsjidojo",
xlab ="length",
ylab="width")
plot(iris$Petal.Length,irisPetal.Width,$
col = "#cc0000",
pch = 9,
main = "iris petsjidojo",
xlab ="length",
ylab="width")
plot(iris$Petal.Length,iris$Petal.Width,
col = "#cc0000",
pch = 9,
main = "iris petsjidojo",
xlab ="length",
ylab="width")
plot(iris$Petal.Length,iris$Petal.Width,
col = "#cc0000",
pch = 6,
main = "iris petsjidojo",
xlab ="length",
ylab="width")
?plot
?exp
plot(exp,1,5)
plot(poisson,1,5)
plot(poisson,1,5,
col = "#cc0000")
plot(poisson,1,5,
+ col = "#cc0000")
plot(exp,1,5,
+ col = "#cc0000")
plot(exp,1,5,
col = "#cc0000")
plot(exp,1,5,
col = "#cc0000",
lwd = 6)
clearPushBack()
?mtcars
head(mtcars)
?cakeplot
a <- table(mtcars$cyl)
plot(a)
barplot(a)
barplot(a,mtcars$name)
barplot(a,mtcars)
barplot(a,mtcars&hp)
barplot(a,mtcars$hp)
?select
?SpatialPoints
library(datasets)
head(iris)
p_load(psych)
library(pacman)
p_load(pysck)
library(psych)
library(pacman)
p_load(psych)
p_load(psych)
p_help(psych)
p_help(psych, web = F)
library(psych)
describe(iris$Sepal.Length)
describe(iris)
hist(iris)
hist(iris$Petal.Length)
summary(iris$Sepal.Length)
hist(iris$Sepal.Length)
hist(iris$Petal.Length == "versicolor")
hist(iris$Petal.Length[iris$Species == "versicolor"])
hist(iris$Sepal.Length[iris$Sepal.Length < 2])
hist(iris$Sepal.Length[iris$Sepal.Length < 2])
hist(iris$Sepal.Length[iris$Sepal.Length < 1])
cat 04
hist(iris$Petal.Length[iris$Petal.Length<4.0])
i.seto <- iris[iris$Species == "setosa"]
i.seto <- iris[iris$Species == "setosa",]
i.seto
iris
clear
head(iris)
head(i.seto)
i.seto <- iris[iris$Species == "setosa"]
i.seto <- iris[iris$Species == "setosa",1]
i.seto
head(i.seto)
i.seto <- iris[iris$Species == "setosa",0]
head(i.seto)
i.seto
i.seto
head(i.seto)
i.seto <- iris[iris$Species == "setosa",2]
head(i.seto)
i.seto <- iris[iris$Species == "setosa",5]
head(i.seto)
i.seto
rm(list = ls())
F
type(FALSE)
typeof(FALSE)
is.vector(FALSE)
m1 <- matrix(c(T,F,T,T),nrow=2)
m1
m1 <- matrix(c(T,F,T,T),nrow=2,byrow = T)
m1
m1 <- matrix(c(T,F,T,T),nrow=3,byrow = T)
m1 <- array (c(1:3),c(4,3,2))
m1
m1 <- array (c(1:3),c(4,3,1))
m1
m1 <- array (c(1:3),c(4,3))
m1
m1 <- array (c(1:3),c(4,3),byrow = T)
m1 <- array (c(1:3),c(4,3))
m1 <- array (c(1:3),c(4,3),byrow = T)
m1 <- matrix (c(1:3),c(4,3),byrow = T)
?As
?as
(x1 < 1:3)
(x1 <- 1:3)
(y ,_ 1:9)
(y <- 1:9)
(df1 <- cbind.data.frame(x1,y))
str(df1)
str(iris)
ls()
library(rio)
library("rio")
library(rio""
install.packages(rio)
install.packages("rio")
library(rio)
install.packages("rio")
library(rio)
install.packages("rlang")
library(rio)
install.packages("rlang")
rio_csv
library("rio")
library("rlan g")
library("rlang")
install.packages("rlang")
require(graphics)
-log(dpois(0:7, lambda = 1) * gamma(1+ 0:7)) # == 1
Ni <- rpois(50, lambda = 4); table(factor(Ni, 0:max(Ni)))
1 - ppois(10*(15:25), lambda = 100)  # becomes 0 (cancellation)
ppois(10*(15:25), lambda = 100, lower.tail = FALSE)  # no cancellation
par(mfrow = c(2, 1))
x <- seq(-0.01, 5, 0.01)
plot(x, ppois(x, 1), type = "s", ylab = "F(x)", main = "Poisson(1) CDF")
plot(x, pbinom(x, 100, 0.01), type = "s", ylab = "F(x)",
main = "Binomial(100, 0.01) CDF")
## The (limit) case  lambda = 0 :
stopifnot(identical(dpois(0,0), 1),
identical(ppois(0,0), 1),
identical(qpois(1,0), 0))
dpos(10,8)
dpois(10,8)
ppois(10,8)
library(plotly)
p <- plot_ly(mtcars, x = ~wt, y = ~hp, z = ~qsec,
marker = list(color = ~mpg, colorscale = c('#FFE1A1', '#683531'), showscale = TRUE)) %>%
add_markers() %>%
layout(scene = list(xaxis = list(title = 'Weight'),
yaxis = list(title = 'Gross horsepower'),
zaxis = list(title = '1/4 mile time')),
annotations = list(
x = 1.13,
y = 1.05,
text = 'Miles/(US) gallon',
xref = 'paper',
yref = 'paper',
showarrow = FALSE
))
# Create a shareable link to your chart
# Set up API credentials: https://plot.ly/r/getting-started
chart_link = api_create(p, filename="scatter3d-colorscale")
chart_link
cat("\014")
setwd("~/Desktop/ba")
## Libraries---------------------------------------------------------------------
library(pracma)
library(FNN)
library(pracma)
library(ggplot2)
library(plotly)
library(rlist)
## Const & Parameter-------------------------------------------------------------
# 1 : wrap around, 2: copy edge, 3
filtermode <- 1
cells_per_line <- 3
bool_plot <- FALSE
## Read CSV/data------------------------------------------------------------------
# 1. Read CSV----------------------------------------------
dataframe <- read.csv("data.txt", sep = ",",header = FALSE)
# 2. Formate dataframe by seperating header and data-------
# header
# dataframe
# dimension
header <- dataframe[1,][!is.na(dataframe[1,])]
dataframe <- data.frame(dataframe[2:nrow(dataframe),])
rownames(dataframe) <- seq(length = nrow(dataframe))
dimension <- header[2]
## Apply smoothening filter--------------------------------------------------------
# 1. divide dataframe into cells----------------------------
# data_cell_frame
source("data_into_cell.R")
# 2. seperate outer and inner indices-----------------------
# inner_indices
# outer_indices
source("seperate_inner_outer.R")
# 3. calculate mean of inner cells--------------------------
# mean_data_cell_frame
source("mean_inner_cells.R")
# 4. calculate mean of outer cells according to parameter---
source("tmp.R")
## Prepare data for kNN------------------------------------------------------------
# kNN_mean_distance
# for this calculatation we use the mean of dim*2 closest neighbors as the radius of the n dimensional sphere
kNN_data <- get.knn(dataframe, k=dimension*4, algorithm=c("kd_tree", "cover_tree", "CR", "brute"))
kNN_neighbors <- data.frame(kNN_data[1])
kNN_distance <- data.frame(kNN_data[2])
kNN_mean_distance <- rowMeans(kNN_distance)
## Density group finding via "watershed/waterfilling" ----------------------------
# group_frame
# We go through all densities via the weightened kNN adjacency matrix
group_frame <- c(seq(1:header[1]))
number_of_groups <- length(unique(group_frame))
repeat{
for (current_i in seq(1:header[1])){
current_node <- group_frame[current_i]
# find current_nodes next possible greater radius node
index <- which(kNN_mean_distance[c(kNN_neighbors[current_node,],recursive = TRUE)] %in% max(kNN_mean_distance[c(kNN_neighbors[current_node,],recursive = TRUE)]))
next_node <- kNN_neighbors[current_node,index]
next_node_distance <- kNN_mean_distance[next_node]
# check wether lowest denisty neighbor is lower than the point itself
if (kNN_mean_distance[current_node] < kNN_mean_distance[next_node]) {
# update belonging list
group_frame[current_i] <- next_node
}
cat("index: ",current_i,"current node: ",current_node, " ",kNN_mean_distance[current_node],
" | note: ",c(kNN_neighbors[current_i,index],recursive = TRUE)," ", kNN_mean_distance[index],
" | next: ", group_frame[current_node] ,"\n")
}
cat("\n")
# If no new groups can be formed, we will break out of the loop
tmp_groups <- number_of_groups
number_of_groups <- length(unique(group_frame))
if(number_of_groups ==  tmp_groups){
break
}
}
## define what a void is----------------------------------------------------
# if the density in a subvoid is less then the average, subvoid will be declared as a not void
cell_frame = unique(group_frame)
data_per_cell = table(group_frame)
density_per_radius = kNN_mean_distance[cell_frame] / data_per_cell
#determin wether data is real data or void
tmp_index <- density_per_radius > mean(density_per_radius)
void_cells <- strtoi(rownames(tmp_index[which(tmp_index == TRUE)]))
data_cells <- strtoi(rownames(tmp_index[which(tmp_index == FALSE)]))
void_index <- which(group_frame %in% void_cells)
data_index <- which(group_frame %in% data_cells)
## combining voids ---------------------------------------------------------
#create new dataframe which holds cell and the subvoids
datalist = list()
for (i in c(1:length(void_cells))){
# get index of each vell with its subvoids
subvoid_index <- void_index[which(group_frame[void_index]  %in% void_cells[i])]
if(length(subvoid_index) != 0){
tmp <- dataframe[subvoid_index,]
# use mean as new coordinate
datalist[[i]] <- colMeans(tmp)
}else{
}
}
subvoid_frame <- do.call(rbind, datalist)
## plot block --------------------------------------------------------
if (bool_plot){
## slices ------------------------------------------------------------
#take slice from the Y axis
p <- source("plot_3d_slice.R")
p
## 3d plot data frame with combined void -----------------------------
p <- source("plot_3d_void.R")
p
## 3d plot data frame with voids cells-------------------------------
p <- source("plot_3d_void_cell.R")
p
## 3d subvoid-group plot---------------------------------------------
p <- source("plot_3d_with_groups.R")
p
## 3d density plot---------------------------------------------------
p <- source("plot_3d_with_denisity.R")
p
## 3d data plot--------------------------------------
p <- source("plot_3d_all_data.R")
p
}
## get surounding indices
mean_data_cell_frame <- data_cell_frame
# define a function to get all neighbours of inner indices
inner_neighbour <- function(position) {
next_neighbours <- position
# first calculate inner indices
for (dimension_index in 0:(dimension-1) ){
# tmp save current list
last_list <- next_neighbours
# check wether new values are still in the frame realm
# in wrapping around we does have 4 cases
# 1. left out of matrix realm
# 2. right out of matrix realm
# 3. downside out of matrix realm
# 4. upside out of matrix realm
# calculate in which tier line values should be
tier <- floor((last_list-1)/cells_per_line)
# get left and right position
next_dim_shift <- cells_per_line^dimension_index
next_neighbours <- list(next_neighbours-next_dim_shift, next_neighbours+next_dim_shift)
next_neighbours <- unlist(next_neighbours)
#look which case we have by checking base and tier values
case_number_index <- list(NULL)
base <- floor((next_neighbours-1)/ (cells_per_line))
for (index in 1:length(tier)){
# length(tier) is half of length(base), there that how we get each pair
tmp_base <- c(base[index],base[index+(length(tier))])
# left or right? 1 == left
### case erkennung hat noch fehler
if(as.integer(which(tmp_base!=tier[index])) == 1){
tmp_index <- index
}else{
tmp_index <- index + length(tier)
}
case_number_index <- list(case_number_index,tmp_index)
}
case_number_index <- unlist(case_number_index)
for (index in 1:length(tier)){
tmp_value <- next_neighbours[case_number_index[index]]
cmp_value <- last_list[index]
exponent <- ceiling(cmp_value/cells_per_line)
# 1. case left is out of frame realm
if(tmp_value < cmp_value){
#calculate new position value
tmp <- cells_per_line^(exponent) - tmp_value
next_neighbours[case_number_index[index]] <- tmp
next
}
# 2. case left is out of frame realm
if(tmp_value > cmp_value){
#calculate new position value
tmp <- cells_per_line^(exponent) + tmp_value
next_neighbours[case_number_index[index]] <- tmp
next
}
next_neighbours <- unlist(next_neighbours)
}
next_neighbours <- list(next_neighbours,last_list)
next_neighbours <- unlist(next_neighbours)
}
return(next_neighbours)
}
inner_neighbour(1)
source("tmp.R")
outer_neighbour(1)
length(unique(outer_neighbour(1)))
