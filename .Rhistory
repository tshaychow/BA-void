library(pacman)
library(mgcv)
detach("package:mgcv", unload = TRUE)
detach("package:methods", unload = TRUE)
p_unload(all)
cat("\014")
cat("\014")
library(datasets)
head(iris)
?plot
?p_unpack
??p_unpack
plot(iris$Species)
plot(iris$Petal.Length)
plot(iris$Petal.Width)
plot(iris$Species,iris$Petal.Width)
plot(iris$Petal.Width,iris$Species)
plot(iris$Petal.Width,iris$Petal.Length)
plot (iris)
plot(iris$Petal.Length,iris&Petal.Width,)
plot(iris$Petal.Length,iris&Petal.Width,
col = "#cc0000",
pch = 19,
main = "iris petsjidojo",
xlab ="length",
ylab="width")
plot(iris$Petal.Length,irisPetal.Width,$
col = "#cc0000",
pch = 19,
main = "iris petsjidojo",
xlab ="length",
ylab="width")
plot(iris$Petal.Length,iris$Petal.Width,
col = "#cc0000",
pch = 19,
main = "iris petsjidojo",
xlab ="length",
ylab="width")
plot(iris$Petal.Length,iris$Petal.Width,
col = "#cc0000",
pch = 1,
main = "iris petsjidojo",
xlab ="length",
ylab="width")
plot(iris$Petal.Length,iris$Petal.Width,
col = "#cc0000",
pch = 5,
main = "iris petsjidojo",
xlab ="length",
ylab="width")
plot(iris$Petal.Length,irisPetal.Width,$
col = "#cc0000",
pch = 9,
main = "iris petsjidojo",
xlab ="length",
ylab="width")
plot(iris$Petal.Length,irisPetal.Width,$
col = "#cc0000",
pch = 9,
main = "iris petsjidojo",
xlab ="length",
ylab="width")
plot(iris$Petal.Length,iris$Petal.Width,
col = "#cc0000",
pch = 9,
main = "iris petsjidojo",
xlab ="length",
ylab="width")
plot(iris$Petal.Length,iris$Petal.Width,
col = "#cc0000",
pch = 6,
main = "iris petsjidojo",
xlab ="length",
ylab="width")
?plot
?exp
plot(exp,1,5)
plot(poisson,1,5)
plot(poisson,1,5,
col = "#cc0000")
plot(poisson,1,5,
+ col = "#cc0000")
plot(exp,1,5,
+ col = "#cc0000")
plot(exp,1,5,
col = "#cc0000")
plot(exp,1,5,
col = "#cc0000",
lwd = 6)
clearPushBack()
?mtcars
head(mtcars)
?cakeplot
a <- table(mtcars$cyl)
plot(a)
barplot(a)
barplot(a,mtcars$name)
barplot(a,mtcars)
barplot(a,mtcars&hp)
barplot(a,mtcars$hp)
?select
?SpatialPoints
library(datasets)
head(iris)
p_load(psych)
library(pacman)
p_load(pysck)
library(psych)
library(pacman)
p_load(psych)
p_load(psych)
p_help(psych)
p_help(psych, web = F)
library(psych)
describe(iris$Sepal.Length)
describe(iris)
hist(iris)
hist(iris$Petal.Length)
summary(iris$Sepal.Length)
hist(iris$Sepal.Length)
hist(iris$Petal.Length == "versicolor")
hist(iris$Petal.Length[iris$Species == "versicolor"])
hist(iris$Sepal.Length[iris$Sepal.Length < 2])
hist(iris$Sepal.Length[iris$Sepal.Length < 2])
hist(iris$Sepal.Length[iris$Sepal.Length < 1])
cat 04
hist(iris$Petal.Length[iris$Petal.Length<4.0])
i.seto <- iris[iris$Species == "setosa"]
i.seto <- iris[iris$Species == "setosa",]
i.seto
iris
clear
head(iris)
head(i.seto)
i.seto <- iris[iris$Species == "setosa"]
i.seto <- iris[iris$Species == "setosa",1]
i.seto
head(i.seto)
i.seto <- iris[iris$Species == "setosa",0]
head(i.seto)
i.seto
i.seto
head(i.seto)
i.seto <- iris[iris$Species == "setosa",2]
head(i.seto)
i.seto <- iris[iris$Species == "setosa",5]
head(i.seto)
i.seto
rm(list = ls())
F
type(FALSE)
typeof(FALSE)
is.vector(FALSE)
m1 <- matrix(c(T,F,T,T),nrow=2)
m1
m1 <- matrix(c(T,F,T,T),nrow=2,byrow = T)
m1
m1 <- matrix(c(T,F,T,T),nrow=3,byrow = T)
m1 <- array (c(1:3),c(4,3,2))
m1
m1 <- array (c(1:3),c(4,3,1))
m1
m1 <- array (c(1:3),c(4,3))
m1
m1 <- array (c(1:3),c(4,3),byrow = T)
m1 <- array (c(1:3),c(4,3))
m1 <- array (c(1:3),c(4,3),byrow = T)
m1 <- matrix (c(1:3),c(4,3),byrow = T)
?As
?as
(x1 < 1:3)
(x1 <- 1:3)
(y ,_ 1:9)
(y <- 1:9)
(df1 <- cbind.data.frame(x1,y))
str(df1)
str(iris)
ls()
library(rio)
library("rio")
library(rio""
install.packages(rio)
install.packages("rio")
library(rio)
install.packages("rio")
library(rio)
install.packages("rlang")
library(rio)
install.packages("rlang")
rio_csv
library("rio")
library("rlan g")
library("rlang")
install.packages("rlang")
require(graphics)
-log(dpois(0:7, lambda = 1) * gamma(1+ 0:7)) # == 1
Ni <- rpois(50, lambda = 4); table(factor(Ni, 0:max(Ni)))
1 - ppois(10*(15:25), lambda = 100)  # becomes 0 (cancellation)
ppois(10*(15:25), lambda = 100, lower.tail = FALSE)  # no cancellation
par(mfrow = c(2, 1))
x <- seq(-0.01, 5, 0.01)
plot(x, ppois(x, 1), type = "s", ylab = "F(x)", main = "Poisson(1) CDF")
plot(x, pbinom(x, 100, 0.01), type = "s", ylab = "F(x)",
main = "Binomial(100, 0.01) CDF")
## The (limit) case  lambda = 0 :
stopifnot(identical(dpois(0,0), 1),
identical(ppois(0,0), 1),
identical(qpois(1,0), 0))
dpos(10,8)
dpois(10,8)
ppois(10,8)
library(plotly)
p <- plot_ly(mtcars, x = ~wt, y = ~hp, z = ~qsec,
marker = list(color = ~mpg, colorscale = c('#FFE1A1', '#683531'), showscale = TRUE)) %>%
add_markers() %>%
layout(scene = list(xaxis = list(title = 'Weight'),
yaxis = list(title = 'Gross horsepower'),
zaxis = list(title = '1/4 mile time')),
annotations = list(
x = 1.13,
y = 1.05,
text = 'Miles/(US) gallon',
xref = 'paper',
yref = 'paper',
showarrow = FALSE
))
# Create a shareable link to your chart
# Set up API credentials: https://plot.ly/r/getting-started
chart_link = api_create(p, filename="scatter3d-colorscale")
chart_link
# divide dataframe into cells
cellsize <- 0.1
cells_per_line <- 1/cellsize
data_cell_matrix <- array(dim = (rep(cells_per_line,dimension)))
# fill data_cell_matrix with amount of points in each cell
cell_dimension_counter <- array(rep(0,dimension),dimension)
dimension_counter <- 1
position_counter <- array(rep(0,dimension),dim = dimension)
for (cell_index in 1:length(data_cell_matrix)){
cell_data <- list(NA)
for (dimension_index in c(1:dimension)){
# possible data points in cell
cell_data <- list(cell_data,which(dataframe[dimension_index] >= cellsize* position_counter[dimension_index] & dataframe[dimension_index]  < cellsize*(position_counter[dimension_index] +1)))
# getnext coordinates
cell_dimension_counter[dimension] <- (cell_dimension_counter[dimension] + 1) %% cells_per_line
}
# get next dimension coordinates
pos_index <- 1
position_counter[pos_index] <- position_counter[pos_index] + 1
while (position_counter[pos_index] >= cells_per_line){
position_counter[pos_index] <- position_counter[pos_index] %% cells_per_line
if (position_counter[pos_index] != 0) {
break;
}
pos_index <- pos_index %% dimension
pos_index <- pos_index + 1
position_counter[pos_index] <- position_counter[pos_index] + 1
}
# shape list for better computation
cell_data <- unlist(cell_data)
# search for data which are in the cells
data_index <- strtoi(names(which(table(cell_data) == dimension)))
# replace NA with density of each cell
if (length(data_index) == 0){
data_index <- 0
data_cell_matrix[cell_index] <- 0
}else{
data_cell_matrix[cell_index] <- (data_index)
}
}
#data_cell_matrix
cat("\014")
setwd("~/Desktop/ba")
## Libraries-------------------------------------------
library(pracma)
library(FNN)
library(pracma)
library(ggplot2)
library(plotly)
library(rlist)
## Read CSV/data---------------------------------------
# header = number of elements and dimension
# dataframes = coordinates of data
dataframe <- read.csv("data.txt", sep = ",",header = FALSE)
header <- dataframe[1,][!is.na(dataframe[1,])]
dataframe <- data.frame(dataframe[2:nrow(dataframe),])
rownames(dataframe) <- seq(length = nrow(dataframe))
dimension <- header[2]
## Use smoothening filter---------------------------------------------------------
# divide dataframe into cells----------------------------
cellsize <- 0.1
cells_per_line <- 1/cellsize
data_cell_matrix <- array(dim = (rep(cells_per_line,dimension)))
# fill data_cell_matrix with amount of points in each cell
cell_dimension_counter <- array(rep(0,dimension),dimension)
dimension_counter <- 1
position_counter <- array(rep(0,dimension),dim = dimension)
for (cell_index in 1:length(data_cell_matrix)){
cell_data <- list(NA)
for (dimension_index in c(1:dimension)){
# possible data points in cell
cell_data <- list(cell_data,which(dataframe[dimension_index] >= cellsize* position_counter[dimension_index] & dataframe[dimension_index]  < cellsize*(position_counter[dimension_index] +1)))
# getnext coordinates
cell_dimension_counter[dimension] <- (cell_dimension_counter[dimension] + 1) %% cells_per_line
}
# get next dimension coordinates
pos_index <- 1
position_counter[pos_index] <- position_counter[pos_index] + 1
while (position_counter[pos_index] >= cells_per_line){
position_counter[pos_index] <- position_counter[pos_index] %% cells_per_line
if (position_counter[pos_index] != 0) {
break;
}
pos_index <- pos_index %% dimension
pos_index <- pos_index + 1
position_counter[pos_index] <- position_counter[pos_index] + 1
}
# shape list for better computation
cell_data <- unlist(cell_data)
# search for data which are in the cells
data_index <- strtoi(names(which(table(cell_data) == dimension)))
# replace NA with density of each cell
if (length(data_index) == 0){
data_index <- 0
data_cell_matrix[cell_index] <- 0
}else{
data_cell_matrix[cell_index] <- length(data_index)
}
}
# get the average of each cell --------------------
data_cell_matrix
## Prepare data for denisty calculation with kNN--------
#for this calculatation we use the mean of dim*2 closest neighbors as the radius of the n dimensional sphere
kNN_data <- get.knn(dataframe, k=dimension*4, algorithm=c("kd_tree", "cover_tree", "CR", "brute"))
kNN_neighbors <- data.frame(kNN_data[1])
kNN_distance <- data.frame(kNN_data[2])
kNN_mean_distance <- rowMeans(kNN_distance)
## Density group finding via "watershed/waterfilling"
# We go through all densities via the weightened kNN adjacency matrix
group_frame <- c(seq(1:header[1]))
number_of_groups <- length(unique(group_frame))
repeat{
for (current_i in seq(1:header[1])){
current_node <- group_frame[current_i]
# find current_nodes next possible greater radius node
index <- which(kNN_mean_distance[c(kNN_neighbors[current_node,],recursive = TRUE)] %in% max(kNN_mean_distance[c(kNN_neighbors[current_node,],recursive = TRUE)]))
next_node <- kNN_neighbors[current_node,index]
next_node_distance <- kNN_mean_distance[next_node]
# check wether lowest denisty neighbor is lower than the point itself
if (kNN_mean_distance[current_node] < kNN_mean_distance[next_node]) {
# update belonging list
group_frame[current_i] <- next_node
}
cat("index: ",current_i,"current node: ",current_node, " ",kNN_mean_distance[current_node],
" | note: ",c(kNN_neighbors[current_i,index],recursive = TRUE)," ", kNN_mean_distance[index],
" | next: ", group_frame[current_node] ,"\n")
}
cat("\n")
# If no new groups can be formed, we will break
tmp_groups <- number_of_groups
number_of_groups <- length(unique(group_frame))
if(number_of_groups ==  tmp_groups){
break
}
}
# define what a void is---------------------------------------
# if the density in a subvoid is less then the average, subvoid will be declared as a not void
cell_frame = unique(group_frame)
data_per_cell = table(group_frame)
density_per_radius = kNN_mean_distance[cell_frame] / data_per_cell
#determin wether data is real data or void
tmp_index <- density_per_radius > mean(density_per_radius)
void_cells <- strtoi(rownames(tmp_index[which(tmp_index == TRUE)]))
data_cells <- strtoi(rownames(tmp_index[which(tmp_index == FALSE)]))
void_index <- which(group_frame %in% void_cells)
data_index <- which(group_frame %in% data_cells)
## combining voids --------------------------------------------------
#create new dataframe which holds cell and the subvoids
datalist = list()
for (i in c(1:length(void_cells))){
# get index of each vell with its subvoids
subvoid_index <- void_index[which(group_frame[void_index]  %in% void_cells[i])]
if(length(subvoid_index) != 0){
tmp <- dataframe[subvoid_index,]
# use mean as new coordinate
datalist[[i]] <- colMeans(tmp)
}else{
}
}
subvoid_frame <- do.call(rbind, datalist)
## plot block --------------------------------------------------------
## slices ------------------------------------------------------------
#take slice from the Y axis
p <- source("plot_3d_slice.R")
p
## 3d plot data frame with combined void -----------------------------
p <- source("plot_3d_void.R")
p
## 3d plot data frame with voids cells-------------------------------
p <- source("plot_3d_void_cell.R")
p
## 3d subvoid-group plot--------------------------------------
p <- source("plot_3d_with_groups.R")
p
## 3d density plot--------------------------------------
p <- source("plot_3d_with_denisity.R")
p
## 3d data plot--------------------------------------
p <- source("plot_3d_all_data.R")
p
# density field
# divide dataframe into cells
cellsize <- 0.1
cells_per_line <- 1/cellsize
data_cell_matrix <- array(dim = (rep(cells_per_line,dimension)))
# fill data_cell_matrix with amount of points in each cell
cell_dimension_counter <- array(rep(0,dimension),dimension)
dimension_counter <- 1
position_counter <- array(rep(0,dimension),dim = dimension)
for (cell_index in 1:length(data_cell_matrix)){
cell_data <- list(NA)
for (dimension_index in c(1:dimension)){
# possible data points in cell
cell_data <- list(cell_data,which(dataframe[dimension_index] >= cellsize* position_counter[dimension_index] & dataframe[dimension_index]  < cellsize*(position_counter[dimension_index] +1)))
# getnext coordinates
cell_dimension_counter[dimension] <- (cell_dimension_counter[dimension] + 1) %% cells_per_line
}
# get next dimension coordinates
pos_index <- 1
position_counter[pos_index] <- position_counter[pos_index] + 1
while (position_counter[pos_index] >= cells_per_line){
position_counter[pos_index] <- position_counter[pos_index] %% cells_per_line
if (position_counter[pos_index] != 0) {
break;
}
pos_index <- pos_index %% dimension
pos_index <- pos_index + 1
position_counter[pos_index] <- position_counter[pos_index] + 1
}
# shape list for better computation
cell_data <- unlist(cell_data)
# search for data which are in the cells
data_index <- strtoi(names(which(table(cell_data) == dimension)))
# replace NA with density of each cell
if (length(data_index) == 0){
data_index <- 0
data_cell_matrix[cell_index] <- 0
}else{
data_cell_matrix[cell_index] <- (data_index)
}
}
#data_cell_matrix
data_cell_matrix[cell_index] <- length(data_index)
# divide dataframe into cells
cellsize <- 0.1
cells_per_line <- 1/cellsize
data_cell_matrix <- array(dim = (rep(cells_per_line,dimension)))
# fill data_cell_matrix with amount of points in each cell
cell_dimension_counter <- array(rep(0,dimension),dimension)
dimension_counter <- 1
position_counter <- array(rep(0,dimension),dim = dimension)
for (cell_index in 1:length(data_cell_matrix)){
cell_data <- list(NA)
for (dimension_index in c(1:dimension)){
# possible data points in cell
cell_data <- list(cell_data,which(dataframe[dimension_index] >= cellsize* position_counter[dimension_index] & dataframe[dimension_index]  < cellsize*(position_counter[dimension_index] +1)))
# getnext coordinates
cell_dimension_counter[dimension] <- (cell_dimension_counter[dimension] + 1) %% cells_per_line
}
# get next dimension coordinates
pos_index <- 1
position_counter[pos_index] <- position_counter[pos_index] + 1
while (position_counter[pos_index] >= cells_per_line){
position_counter[pos_index] <- position_counter[pos_index] %% cells_per_line
if (position_counter[pos_index] != 0) {
break;
}
pos_index <- pos_index %% dimension
pos_index <- pos_index + 1
position_counter[pos_index] <- position_counter[pos_index] + 1
}
# shape list for better computation
cell_data <- unlist(cell_data)
# search for data which are in the cells
data_index <- strtoi(names(which(table(cell_data) == dimension)))
# replace NA with density of each cell
if (length(data_index) == 0){
data_index <- 0
data_cell_matrix[cell_index] <- 0
}else{
data_cell_matrix[cell_index] <- length(data_index)
}
}
#data_cell_matrix
data_cell_matrix
movavg(data_cell_matrix)
movavg(data_cell_matrix,1000)
movavg(data_cell_matrix,10000)
movavg(data_cell_matrix,100)
movavg(data_cell_matrix,9, type = "t")
