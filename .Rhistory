p
p1 <- plot_ly(z = mean_data_cell_frame[1,,], colors = "Greys",type = "heatmap")
p2 <- plot_ly(z = mean_data_cell_frame[2,,], colors = "Greys", type = "heatmap")
p3 <- plot_ly(z = mean_data_cell_frame[3,,], colors = "Greys", type = "heatmap")
#p4 <- plot_ly(z = mean_data_cell_frame[4,,], colors = "Greys", type = "heatmap")
# p5 <- plot_ly(z = mean_data_cell_frame[5,,], type = "heatmap")
# p6 <- plot_ly(z = mean_data_cell_frame[6,,], type = "heatmap")
# p7 <- plot_ly(z = mean_data_cell_frame[7,,], type = "heatmap")
# p8 <- plot_ly(z = mean_data_cell_frame[8,,], type = "heatmap")
# p9 <- plot_ly(z = mean_data_cell_frame[9,,], type = "heatmap")
# p10<- plot_ly(z = mean_data_cell_frame[10,,], type = "heatmap")
p <- subplot(p1,p2,p3,nrows = 4)
p
p1 <- plot_ly(z = mean_data_cell_frame[1,,], colors = "Greys",type = "heatmap")
p2 <- plot_ly(z = mean_data_cell_frame[2,,], colors = "Greys", type = "heatmap")
p3 <- plot_ly(z = mean_data_cell_frame[3,,], colors = "Greys", type = "heatmap")
#p4 <- plot_ly(z = mean_data_cell_frame[4,,], colors = "Greys", type = "heatmap")
# p5 <- plot_ly(z = mean_data_cell_frame[5,,], type = "heatmap")
# p6 <- plot_ly(z = mean_data_cell_frame[6,,], type = "heatmap")
# p7 <- plot_ly(z = mean_data_cell_frame[7,,], type = "heatmap")
# p8 <- plot_ly(z = mean_data_cell_frame[8,,], type = "heatmap")
# p9 <- plot_ly(z = mean_data_cell_frame[9,,], type = "heatmap")
# p10<- plot_ly(z = mean_data_cell_frame[10,,], type = "heatmap")
p <- subplot(p1,p2,p3,nrows = 3)
p
mean_data_cell_frame
cat("\014")
setwd("~/Desktop/ba")
## Libraries---------------------------------------------------------------------
library(pracma)
library(FNN)
library(pracma)
library(ggplot2)
library(plotly)
library(rlist)
## Const & Parameter-------------------------------------------------------------
# 1 : wrap around, 2: copy edge, 3
filtermode <- 1
cells_per_line <- 4
bool_plot <- FALSE
## Read CSV/data------------------------------------------------------------------
# 1. Read CSV----------------------------------------------
dataframe <- read.csv("data.txt", sep = ",",header = FALSE)
# 2. Formate dataframe by seperating header and data-------
# header
# dataframe
# dimension
header <- dataframe[1,][!is.na(dataframe[1,])]
dataframe <- data.frame(dataframe[2:nrow(dataframe),])
rownames(dataframe) <- seq(length = nrow(dataframe))
dimension <- header[2]
## Apply smoothening filter--------------------------------------------------------
# 1. divide dataframe into cells----------------------------
# data_cell_frame
source("data_into_cell.R")
# 2. seperate outer and inner indices-----------------------
# inner_indices
# outer_indices
source("seperate_inner_outer.R")
# 3. calculate mean of inner cells--------------------------
# mean_data_cell_frame
source("mean_inner_cells.R")
# 4. calculate mean of outer cells according to parameter---
if (filtermode == 1){
source("mean_outer_cells_wrap.R")
}else{
source("mean_outer_cells_copy.R")
}
## Prepare data for kNN------------------------------------------------------------
# kNN_mean_distance
# for this calculatation we use the mean of dim*2 closest neighbors as the radius of the n dimensional sphere
##
## No need for kNN calculations, because of cell structure
#kNN_data <- get.knn(mean_data_cell_frame, k=dimension*2, algorithm=c("kd_tree", "cover_tree", "CR", "brute"))
#kNN_neighbors <- data.frame(kNN_data[1])
#kNN_distance <- data.frame(kNN_data[2])
#kNN_mean_distance <- rowMeans(kNN_distance)
## Density group finding via "watershed/waterfilling" ----------------------------
# group_frame
# We go through all densities via the weightened kNN adjacency matrix
source("new_watershed.R")
## define what a void is----------------------------------------------------
# if the density in a subvoid is less then the average, subvoid will be declared as a not void
cell_frame = unique(group_frame)
data_per_cell = table(group_frame)
density_per_radius = mean_data_cell_frame[cell_frame] / data_per_cell
#determin wether data is real data or void
tmp_index <- density_per_radius > mean(density_per_radius)
void_cells <- strtoi(names(tmp_index[which(tmp_index == TRUE)]))
data_cells <- strtoi(names(tmp_index[which(tmp_index == FALSE)]))
void_index <- which(group_frame %in% void_cells)
data_index <- which(group_frame %in% data_cells)
## combining voids ---------------------------------------------------------
#create new dataframe which holds cell and the subvoids
datalist = list()
for (i in c(1:length(void_cells))){
# get index of each vell with its subvoids
subvoid_index <- void_index[which(group_frame[void_index]  %in% void_cells[i])]
if(length(subvoid_index) != 0){
tmp <- dataframe[subvoid_index,]
# use mean as new coordinate
datalist[[i]] <- colMeans(tmp)
}else{
}
}
subvoid_frame <- do.call(rbind, datalist)
## plot block --------------------------------------------------------
p <-source("new_plot/plot3d_heatmap.R")
p
# old plots
if (bool_plot){
## slices ------------------------------------------------------------
#take slice from the Y axis
p <- source("old_plot/plot_3d_slice.R")
p
## 3d plot data frame with combined void -----------------------------
p <- source("old_plot/plot_3d_void.R")
p
## 3d plot data frame with voids cells-------------------------------
p <- source("old_plot/plot_3d_void_cell.R")
p
## 3d subvoid-group plot---------------------------------------------
p <- source("old_plot/plot_3d_with_groups.R")
p
## 3d density plot---------------------------------------------------
p <- source("old_plot/plot_3d_with_denisity.R")
p
## 3d data plot--------------------------------------
p <- source("old_plot/plot_3d_all_data.R")
p
}
cell_frame = unique(group_frame)
data_per_cell = table(group_frame)
density_per_radius = mean_data_cell_frame[cell_frame] / data_per_cell
cell_frame
data_per_cell
density_per_radius
tmp_index <- density_per_radius > mean(density_per_radius)
tmp_index
void_cells <- strtoi(names(tmp_index[which(tmp_index == TRUE)]))
data_cells <- strtoi(names(tmp_index[which(tmp_index == FALSE)]))
void_index <- which(group_frame %in% void_cells)
data_index <- which(group_frame %in% data_cells)
void_index
data_index
void_cells
group_frame
tmp_data_frame
cat("\014")
setwd("~/Desktop/ba")
## Libraries---------------------------------------------------------------------
library(pracma)
library(FNN)
library(pracma)
library(ggplot2)
library(plotly)
library(rlist)
## Const & Parameter-------------------------------------------------------------
# 1 : wrap around, 2: copy edge, 3
filtermode <- 1
cells_per_line <- 4
bool_plot <- FALSE
## Read CSV/data------------------------------------------------------------------
# 1. Read CSV----------------------------------------------
dataframe <- read.csv("data.txt", sep = ",",header = FALSE)
# 2. Formate dataframe by seperating header and data-------
# header
# dataframe
# dimension
header <- dataframe[1,][!is.na(dataframe[1,])]
dataframe <- data.frame(dataframe[2:nrow(dataframe),])
rownames(dataframe) <- seq(length = nrow(dataframe))
dimension <- header[2]
## Apply smoothening filter--------------------------------------------------------
# 1. divide dataframe into cells----------------------------
# data_cell_frame
source("data_into_cell.R")
# 2. seperate outer and inner indices-----------------------
# inner_indices
# outer_indices
source("seperate_inner_outer.R")
# 3. calculate mean of inner cells--------------------------
# mean_data_cell_frame
source("mean_inner_cells.R")
# 4. calculate mean of outer cells according to parameter---
if (filtermode == 1){
source("mean_outer_cells_wrap.R")
}else{
source("mean_outer_cells_copy.R")
}
## Prepare data for kNN------------------------------------------------------------
# kNN_mean_distance
# for this calculatation we use the mean of dim*2 closest neighbors as the radius of the n dimensional sphere
## No need for kNN calculations, because of cell structure
#kNN_data <- get.knn(mean_data_cell_frame, k=dimension*2, algorithm=c("kd_tree", "cover_tree", "CR", "brute"))
#kNN_neighbors <- data.frame(kNN_data[1])
#kNN_distance <- data.frame(kNN_data[2])
#kNN_mean_distance <- rowMeans(kNN_distance)
## Density group finding via "watershed/waterfilling" ----------------------------
# group_frame
# We go through all densities via the weightened kNN adjacency matrix
source("new_watershed.R")
## define what a void is----------------------------------------------------
# if the density in a subvoid is less then the average, subvoid will be declared as a not void
cell_frame = unique(group_frame)
data_per_cell = table(group_frame)
density_per_radius = mean_data_cell_frame[cell_frame] / data_per_cell
#determin whether data is real data or void
tmp_index <- density_per_radius > mean(density_per_radius)
void_cells <- strtoi(names(tmp_index[which(tmp_index == TRUE)]))
data_cells <- strtoi(names(tmp_index[which(tmp_index == FALSE)]))
void_index <- which(group_frame %in% void_cells)
data_index <- which(group_frame %in% data_cells)
## combining voids ---------------------------------------------------------
#create new dataframe which holds cell and the subvoids
datalist = list()
for (i in c(1:length(void_cells))){
# get index of each vell with its subvoids
subvoid_index <- void_index[which(group_frame[void_index]  %in% void_cells[i])]
if(length(subvoid_index) != 0){
tmp <- dataframe[subvoid_index,]
# use mean as new coordinate
datalist[[i]] <- colMeans(tmp)
}else{
}
}
subvoid_frame <- do.call(rbind, datalist)
## plot block --------------------------------------------------------
p <-source("new_plot/plot3d_heatmap.R")
p
# old plots
if (bool_plot){
## slices ------------------------------------------------------------
#take slice from the Y axis
p <- source("old_plot/plot_3d_slice.R")
p
## 3d plot data frame with combined void -----------------------------
p <- source("old_plot/plot_3d_void.R")
p
## 3d plot data frame with voids cells-------------------------------
p <- source("old_plot/plot_3d_void_cell.R")
p
## 3d subvoid-group plot---------------------------------------------
p <- source("old_plot/plot_3d_with_groups.R")
p
## 3d density plot---------------------------------------------------
p <- source("old_plot/plot_3d_with_denisity.R")
p
## 3d data plot--------------------------------------
p <- source("old_plot/plot_3d_all_data.R")
p
}
group_frame
mean_data_cell_frame
subvoid_frame
datalist = list()
for (i in c(1:length(void_cells))){
# get index of each cell with its subvoids
subvoid_index <- void_index[which(group_frame[void_index]  %in% void_cells[i])]
if(length(subvoid_index) != 0){
tmp <- dataframe[subvoid_index,]
# use mean as new coordinate
datalist[[i]] <- colMeans(tmp)
}else{
}
}
subvoid_frame <- do.call(rbind, datalist)
void_cells
cat("\014")
setwd("~/Desktop/ba")
## Libraries---------------------------------------------------------------------
library(pracma)
library(FNN)
library(pracma)
library(ggplot2)
library(plotly)
library(rlist)
## Const & Parameter-------------------------------------------------------------
# 1 : wrap around, 2: copy edge, 3
filtermode <- 1
cells_per_line <- 4
bool_plot <- FALSE
## Read CSV/data------------------------------------------------------------------
# 1. Read CSV----------------------------------------------
dataframe <- read.csv("data.txt", sep = ",",header = FALSE)
# 2. Formate dataframe by seperating header and data-------
# header
# dataframe
# dimension
header <- dataframe[1,][!is.na(dataframe[1,])]
dataframe <- data.frame(dataframe[2:nrow(dataframe),])
rownames(dataframe) <- seq(length = nrow(dataframe))
dimension <- header[2]
## Apply smoothening filter--------------------------------------------------------
# 1. divide dataframe into cells----------------------------
# data_cell_frame
source("data_into_cell.R")
# 2. seperate outer and inner indices-----------------------
# inner_indices
# outer_indices
source("seperate_inner_outer.R")
# 3. calculate mean of inner cells--------------------------
# mean_data_cell_frame
source("mean_inner_cells.R")
# 4. calculate mean of outer cells according to parameter---
if (filtermode == 1){
source("mean_outer_cells_wrap.R")
}else{
source("mean_outer_cells_copy.R")
}
## Density group finding via "watershed/waterfilling" ----------------------------
# group_frame
# We go through all densities via the weightened kNN adjacency matrix
source("new_watershed.R")
## define what a void is----------------------------------------------------
# if the density in a subvoid is less then the average, subvoid will be declared as a not void
cell_frame = unique(group_frame)
data_per_cell = table(group_frame)
density_per_radius = mean_data_cell_frame[cell_frame] / data_per_cell
#determine whether data is real data or void
tmp_index <- density_per_radius > mean(density_per_radius)
void_cells <- strtoi(names(tmp_index[which(tmp_index == TRUE)]))
data_cells <- strtoi(names(tmp_index[which(tmp_index == FALSE)]))
void_index <- which(group_frame %in% void_cells)
data_index <- which(group_frame %in% data_cells)
## combining voids ---------------------------------------------------------
#create new dataframe which holds cell and the subvoids
datalist = list()
for (i in c(1:length(void_cells))){
# get index of each cell with its subvoids
subvoid_index <- void_index[which(group_frame[void_index]  %in% void_cells[i])]
if(length(subvoid_index) != 0){
tmp <- dataframe[subvoid_index,]
# use mean as new coordinate
datalist[[i]] <- colMeans(tmp)
}else{
}
}
subvoid_frame <- do.call(rbind, datalist)
## plot block --------------------------------------------------------
p <-source("new_plot/plot3d_heatmap.R")
p
# old plots
if (bool_plot){
## slices ------------------------------------------------------------
#take slice from the Y axis
p <- source("old_plot/plot_3d_slice.R")
p
## 3d plot data frame with combined void -----------------------------
p <- source("old_plot/plot_3d_void.R")
p
## 3d plot data frame with voids cells-------------------------------
p <- source("old_plot/plot_3d_void_cell.R")
p
## 3d subvoid-group plot---------------------------------------------
p <- source("old_plot/plot_3d_with_groups.R")
p
## 3d density plot---------------------------------------------------
p <- source("old_plot/plot_3d_with_denisity.R")
p
## 3d data plot--------------------------------------
p <- source("old_plot/plot_3d_all_data.R")
p
}
void_index
data_index
cell_frame
group_frame
cell_frame = unique(group_frame)
cell_frame
group_frame
density_per_radius = mean_data_cell_frame[cell_frame] / data_per_cell
density_per_radius
mean(density_per_radius)
# determine whether data is real data or void
# True = is
#
tmp_index <- density_per_radius > mean(density_per_radius)
tmp_index
cat("\014")
setwd("~/Desktop/ba")
## Libraries---------------------------------------------------------------------
library(pracma)
library(FNN)
library(pracma)
library(ggplot2)
library(plotly)
library(rlist)
## Const & Parameter-------------------------------------------------------------
# 1 : wrap around, 2: copy edge, 3
filtermode <- 1
cells_per_line <- 4
bool_plot <- FALSE
## Read CSV/data------------------------------------------------------------------
# 1. Read CSV----------------------------------------------
dataframe <- read.csv("data.txt", sep = ",",header = FALSE)
# 2. Formate dataframe by seperating header and data-------
# header
# dataframe
# dimension
header <- dataframe[1,][!is.na(dataframe[1,])]
dataframe <- data.frame(dataframe[2:nrow(dataframe),])
rownames(dataframe) <- seq(length = nrow(dataframe))
dimension <- header[2]
## Apply smoothening filter--------------------------------------------------------
# 1. divide dataframe into cells----------------------------
# data_cell_frame
source("data_into_cell.R")
# 2. seperate outer and inner indices-----------------------
# inner_indices
# outer_indices
source("seperate_inner_outer.R")
# 3. calculate mean of inner cells--------------------------
# mean_data_cell_frame
source("mean_inner_cells.R")
# 4. calculate mean of outer cells according to parameter---
if (filtermode == 1){
source("mean_outer_cells_wrap.R")
}else{
source("mean_outer_cells_copy.R")
}
## Density group finding via "watershed/waterfilling" ----------------------------
# group_frame
# We go through all densities via the weightened kNN adjacency matrix
source("new_watershed.R")
## define what a void is----------------------------------------------------
# void_index
# data_index
# if the density in a subvoid is less then the average, subvoid will be declared as a not void
cell_frame = unique(group_frame)
data_per_cell = table(group_frame)
density_per_radius = mean_data_cell_frame[cell_frame] / data_per_cell
# determine whether data is real data or void
# True = is real data
# False = is void
tmp_index <- density_per_radius > mean(density_per_radius)
void_cells <- strtoi(names(tmp_index[which(tmp_index == FALSE)]))
data_cells <- strtoi(names(tmp_index[which(tmp_index == TRUE)]))
void_index <- which(group_frame %in% void_cells)
data_index <- which(group_frame %in% data_cells)
## combining voids ---------------------------------------------------------
#create new dataframe which holds cell and the subvoids
datalist = list()
for (i in c(1:length(void_cells))){
# get index of each cell with its subvoids
subvoid_index <- void_index[which(group_frame[void_index]  %in% void_cells[i])]
if(length(subvoid_index) != 0){
tmp <- dataframe[subvoid_index,]
# use mean as new coordinate
datalist[[i]] <- colMeans(tmp)
}else{
}
}
subvoid_frame <- do.call(rbind, datalist)
## plot block --------------------------------------------------------
p <-source("new_plot/plot3d_heatmap.R")
p
# old plots
if (bool_plot){
## slices ------------------------------------------------------------
#take slice from the Y axis
p <- source("old_plot/plot_3d_slice.R")
p
## 3d plot data frame with combined void -----------------------------
p <- source("old_plot/plot_3d_void.R")
p
## 3d plot data frame with voids cells-------------------------------
p <- source("old_plot/plot_3d_void_cell.R")
p
## 3d subvoid-group plot---------------------------------------------
p <- source("old_plot/plot_3d_with_groups.R")
p
## 3d density plot---------------------------------------------------
p <- source("old_plot/plot_3d_with_denisity.R")
p
## 3d data plot--------------------------------------
p <- source("old_plot/plot_3d_all_data.R")
p
}
p <- source("old_plot/plot_3d_all_data.R")
p
void_cells
subvoid_frame
#create new dataframe which holds cell and the subvoids
datalist = list()
for (i in c(1:length(void_cells))){
# get index of each cell with its subvoids
subvoid_index <- void_index[which(group_frame[void_index]  %in% void_cells[i])]
if(length(subvoid_index) != 0){
tmp <- dataframe[subvoid_index,]
# use mean as new coordinate
datalist[[i]] <- colMeans(tmp)
}else{
}
}
subvoid_frame <- do.call(rbind, datalist)
subvoid_frame
void_index
group_frame
void_index
void_cells
data_cells
neighbours(60)
mean_data_cell_frame[neighbours(60)]
mean_data_cell_frame[neighbours(39)]
void_index <- which(group_frame %in% void_cells)
void_index
group_frame
p <-source("new_plot/plot3d_heatmap.R")
p
subvoid_frame
void_cells
