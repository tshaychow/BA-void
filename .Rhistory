mydataframe <- data.frame(matrix(0,nrow= numbers_of_elements,ncol = dimension))
size_of_dim <- ceiling(nthroot(numbers_of_elements,dimension))
#add values
for (i in 1:3){
mydataframe[,i] <- runif(numbers_of_elements,0,1)
}
#plot
mydataframe <- data.frame(mydataframe)
p <- plot_ly(mydataframe, x = mydataframe$X1  , y = mydataframe$X2 , z = mydataframe$X3) %>%
add_markers() %>%
layout(scene = list(xaxis = list(title = 'X',nticks = 20,range=c(0,1)),
yaxis = list(title = 'Y',nticks = 20,range=c(0,1)),
zaxis = list(title = 'Z',nticks = 20,range=c(0,1)),
aspectmode='cube'))
p
## Write into TXT
write.table(list(numbers_of_elements, dimension),file = "data.txt",append=FALSE,row.names = FALSE,col.names = FALSE,sep = ",")
write.table(mydataframe,file = "data.txt",append = TRUE,row.names = FALSE,col.names = FALSE,sep = ",")
cat("\014")
setwd("~/Desktop/ba")
## Libraries-------------------------------------------
library(pracma)
library(FNN)
library(pracma)
library(ggplot2)
library(plotly)
## Read CSV/data---------------------------------------
# header = number of elements and dimension
# dataframes = coordinates of data
dataframe <- read.csv("data.txt", sep = ",",header = FALSE)
header <- dataframe[1,][!is.na(dataframe[1,])]
dataframe <- data.frame(dataframe[2:nrow(dataframe),])
rownames(dataframe) <- seq(length = nrow(dataframe))
## Prepare data for denisty calculation with kNN--------
#for this calculatation we use the mean of dim*2 closest neighbors as the radius of the n dimensional sphere
kNN_data <- get.knn(dataframe, k=header[2]*2, algorithm=c("kd_tree", "cover_tree", "CR", "brute"))
kNN_neighbors <- data.frame(kNN_data[1])
kNN_distance <- data.frame(kNN_data[2])
kNN_mean_distance <- rowMeans(kNN_distance)
## 3d density plot--------------------------------------
p <- source("plot_3d_with_denisity.R")
p
## Density group finding via "watershed/waterfilling"
# We go through all densities via the weightened kNN adjacency matrix
group_frame <- c(seq(1:header[1]))
number_of_groups <- length(unique(group_frame))
repeat{
for (current_i in seq(1:header[1])){
current_node <- group_frame[current_i]
# find current_nodes next possible greater radius node
index <- which(kNN_mean_distance[c(kNN_neighbors[current_node,],recursive = TRUE)] %in% max(kNN_mean_distance[c(kNN_neighbors[current_node,],recursive = TRUE)]))
next_node <- kNN_neighbors[current_node,index]
next_node_distance <- kNN_mean_distance[next_node]
# check wether lowest denisty neighbor is lower than the point itself
if (kNN_mean_distance[current_node] < kNN_mean_distance[next_node]) {
# update belonging list
group_frame[current_i] <- next_node
}
cat("index: ",current_i,"current node: ",current_node, " ",kNN_mean_distance[current_node],
" | note: ",c(kNN_neighbors[current_i,index],recursive = TRUE)," ", kNN_mean_distance[index],
" | next: ", group_frame[current_node] ,"\n")
}
cat("\n")
# If no new groups can be formed, we will break
tmp_groups <- number_of_groups
number_of_groups <- length(unique(group_frame))
if(number_of_groups ==  tmp_groups){
break
}
}
## 3d subvoid-group plot--------------------------------------
p <- source("plot_3d_with_groups.R")
p
# define what a void is---------------------------------------
# if the density in a subvoid is less then the average, subvoid will be declared as a not void
cell_frame = unique(group_frame)
kNN_mean_distance[cell_frame]
data_per_cell = table(group_frame)
density_per_radius = kNN_mean_distance[cell_frame] / data_per_cell
void_index <- density_per_radius > mean(density_per_radius)
void_cells <- strtoi(rownames(void_index[which(void_index == TRUE)]))
data_cells <- strtoi(rownames(void_index[which(void_index == FALSE)]))
void_index <- which(group_frame %in% void_cells)
data_index <- which(group_frame %in% data_cells)
## 3d plot data frame with voids-------------------------------
p <- source("plot_3d_void.R")
p
x <- dataframe[void_index,]$V1
y <- dataframe[void_index,]$V2
z <- dataframe[void_index,]$V3
x_d <- dataframe[data_index,]$V1
y_d <- dataframe[data_index,]$V2
z_d <- dataframe[data_index,]$V3
p <-  plot_ly(x = ~x_d, y = ~y_d, z = ~z_d,type = "scatter3d") %>%
add_trace(x = ~x, y = ~y, z = ~z,type = "mesh3d")  %>%
layout(scene = list(xaxis = list(title = 'X',nticks = 20,range=c(0,1)),
yaxis = list(title = 'Y',nticks = 20,range=c(0,1)),
zaxis = list(title = 'Z',nticks = 20,range=c(0,1)),
aspectmode='cube'))
p
x <- dataframe[void_index,]$V1
y <- dataframe[void_index,]$V2
z <- dataframe[void_index,]$V3
x_d <- dataframe[data_index,]$V1
y_d <- dataframe[data_index,]$V2
z_d <- dataframe[data_index,]$V3
p <- plot_ly(type = "scatter3d",mode = 'markers') %>%
add_markers(x = x_d,
y = y_d,
z = z_d,
text = data_index,
marker = list(color = 'rgb(0,0,0)',
size = 5),
showlegend = FALSE) %>%
add_markers(x = x,
y = y,
z = z,
text = void_index,
marker = list(size = kNN_mean_distance[void_index]*400,
color = group_frame[void_index],
opacity = 0.99,
colorscale = 'Rainbow',
showscale = TRUE),
showlegend = FALSE) %>%
layout(scene = list(xaxis = list(title = 'X',nticks = 20,range=c(0,1)),
yaxis = list(title = 'Y',nticks = 20,range=c(0,1)),
zaxis = list(title = 'Z',nticks = 20,range=c(0,1)),
aspectmode='cube'))
p
void_index <- density_per_radius > mean(density_per_radius)
void_cells <- strtoi(rownames(void_index[which(void_index == TRUE)]))
data_cells <- strtoi(rownames(void_index[which(void_index == FALSE)]))
void_index <- which(group_frame %in% void_cells)
data_index <- which(group_frame %in% data_cells)
x <- dataframe[void_index,]$V1
y <- dataframe[void_index,]$V2
z <- dataframe[void_index,]$V3
x_d <- dataframe[data_index,]$V1
y_d <- dataframe[data_index,]$V2
z_d <- dataframe[data_index,]$V3
p <- plot_ly(type = "scatter3d",mode = 'markers') %>%
add_markers(x = x_d,
y = y_d,
z = z_d,
text = data_index,
marker = list(color = 'rgb(0,0,0)',
size = 5),
showlegend = FALSE) %>%
add_markers(x = x,
y = y,
z = z,
text = void_index,
marker = list(size = kNN_mean_distance[void_index]*400,
color = group_frame[void_index],
opacity = 0.99,
colorscale = 'Rainbow',
showscale = TRUE),
showlegend = FALSE) %>%
layout(scene = list(xaxis = list(title = 'X',nticks = 20,range=c(0,1)),
yaxis = list(title = 'Y',nticks = 20,range=c(0,1)),
zaxis = list(title = 'Z',nticks = 20,range=c(0,1)),
aspectmode='cube'))
p
z_d
z
void_index
void_index <- density_per_radius > mean(density_per_radius)
void_cells <- strtoi(rownames(void_index[which(void_index == TRUE)]))
data_cells <- strtoi(rownames(void_index[which(void_index == FALSE)]))
void_index <- which(group_frame %in% void_cells)
data_index <- which(group_frame %in% data_cells)
x <- dataframe[void_index,]$V1
y <- dataframe[void_index,]$V2
z <- dataframe[void_index,]$V3
x_d <- dataframe[data_index,]$V1
y_d <- dataframe[data_index,]$V2
z_d <- dataframe[data_index,]$V3
p <- plot_ly(type = "scatter3d",mode = 'markers') %>%
add_markers(x = x_d,
y = y_d,
z = z_d,
text = data_index,
marker = list(color = 'rgb(0,0,0)',
size = 5),
showlegend = FALSE) %>%
add_markers(x = x,
y = y,
z = z,
text = void_index,
marker = list(size = kNN_mean_distance[void_index]*400,
color = group_frame[void_index],
opacity = 0.99,
colorscale = 'Rainbow',
showscale = TRUE),
showlegend = FALSE) %>%
layout(scene = list(xaxis = list(title = 'X',nticks = 20,range=c(0,1)),
yaxis = list(title = 'Y',nticks = 20,range=c(0,1)),
zaxis = list(title = 'Z',nticks = 20,range=c(0,1)),
aspectmode='cube'))
p
cat("\014")
setwd("~/Desktop/ba")
## Libraries-------------------------------------------
library(pracma)
library(FNN)
library(pracma)
library(ggplot2)
library(plotly)
## Read CSV/data---------------------------------------
# header = number of elements and dimension
# dataframes = coordinates of data
dataframe <- read.csv("data.txt", sep = ",",header = FALSE)
header <- dataframe[1,][!is.na(dataframe[1,])]
dataframe <- data.frame(dataframe[2:nrow(dataframe),])
rownames(dataframe) <- seq(length = nrow(dataframe))
## Prepare data for denisty calculation with kNN--------
#for this calculatation we use the mean of dim*2 closest neighbors as the radius of the n dimensional sphere
kNN_data <- get.knn(dataframe, k=header[2]*2, algorithm=c("kd_tree", "cover_tree", "CR", "brute"))
kNN_neighbors <- data.frame(kNN_data[1])
kNN_distance <- data.frame(kNN_data[2])
kNN_mean_distance <- rowMeans(kNN_distance)
## 3d density plot--------------------------------------
p <- source("plot_3d_with_denisity.R")
p
## Density group finding via "watershed/waterfilling"
# We go through all densities via the weightened kNN adjacency matrix
group_frame <- c(seq(1:header[1]))
number_of_groups <- length(unique(group_frame))
repeat{
for (current_i in seq(1:header[1])){
current_node <- group_frame[current_i]
# find current_nodes next possible greater radius node
index <- which(kNN_mean_distance[c(kNN_neighbors[current_node,],recursive = TRUE)] %in% max(kNN_mean_distance[c(kNN_neighbors[current_node,],recursive = TRUE)]))
next_node <- kNN_neighbors[current_node,index]
next_node_distance <- kNN_mean_distance[next_node]
# check wether lowest denisty neighbor is lower than the point itself
if (kNN_mean_distance[current_node] < kNN_mean_distance[next_node]) {
# update belonging list
group_frame[current_i] <- next_node
}
cat("index: ",current_i,"current node: ",current_node, " ",kNN_mean_distance[current_node],
" | note: ",c(kNN_neighbors[current_i,index],recursive = TRUE)," ", kNN_mean_distance[index],
" | next: ", group_frame[current_node] ,"\n")
}
cat("\n")
# If no new groups can be formed, we will break
tmp_groups <- number_of_groups
number_of_groups <- length(unique(group_frame))
if(number_of_groups ==  tmp_groups){
break
}
}
## 3d subvoid-group plot--------------------------------------
p <- source("plot_3d_with_groups.R")
p
# define what a void is---------------------------------------
# if the density in a subvoid is less then the average, subvoid will be declared as a not void
cell_frame = unique(group_frame)
kNN_mean_distance[cell_frame]
data_per_cell = table(group_frame)
density_per_radius = kNN_mean_distance[cell_frame] / data_per_cell
void_index <- density_per_radius > mean(density_per_radius)
void_cells <- strtoi(rownames(void_index[which(void_index == TRUE)]))
data_cells <- strtoi(rownames(void_index[which(void_index == FALSE)]))
void_index <- which(group_frame %in% void_cells)
data_index <- which(group_frame %in% data_cells)
## 3d plot data frame with voids-------------------------------
p <- source("plot_3d_void.R")
p
void_index
cell_frame
kNN_mean_distance
data_per_cell
density_per_radius
void_index
density_per_radius > mean(density_per_radius)
mean(density_per_radius)
density_per_radius
library(pracma)
library(plotly)
packageVersion('plotly')
#const
setwd("~/Desktop/ba")
dimension = 3
numbers_of_elements = 50
#init data frames
mydataframe <- data.frame(matrix(0,nrow= numbers_of_elements,ncol = dimension))
size_of_dim <- ceiling(nthroot(numbers_of_elements,dimension))
#add values
for (i in 1:3){
mydataframe[,i] <- runif(numbers_of_elements,0,1)
}
#plot
mydataframe <- data.frame(mydataframe)
p <- plot_ly(mydataframe, x = mydataframe$X1  , y = mydataframe$X2 , z = mydataframe$X3) %>%
add_markers() %>%
layout(scene = list(xaxis = list(title = 'X',nticks = 20,range=c(0,1)),
yaxis = list(title = 'Y',nticks = 20,range=c(0,1)),
zaxis = list(title = 'Z',nticks = 20,range=c(0,1)),
aspectmode='cube'))
p
## Write into TXT
write.table(list(numbers_of_elements, dimension),file = "data.txt",append=FALSE,row.names = FALSE,col.names = FALSE,sep = ",")
write.table(mydataframe,file = "data.txt",append = TRUE,row.names = FALSE,col.names = FALSE,sep = ",")
cat("\014")
setwd("~/Desktop/ba")
## Libraries-------------------------------------------
library(pracma)
library(FNN)
library(pracma)
library(ggplot2)
library(plotly)
## Read CSV/data---------------------------------------
# header = number of elements and dimension
# dataframes = coordinates of data
dataframe <- read.csv("data.txt", sep = ",",header = FALSE)
header <- dataframe[1,][!is.na(dataframe[1,])]
dataframe <- data.frame(dataframe[2:nrow(dataframe),])
rownames(dataframe) <- seq(length = nrow(dataframe))
## Prepare data for denisty calculation with kNN--------
#for this calculatation we use the mean of dim*2 closest neighbors as the radius of the n dimensional sphere
kNN_data <- get.knn(dataframe, k=header[2]*2, algorithm=c("kd_tree", "cover_tree", "CR", "brute"))
kNN_neighbors <- data.frame(kNN_data[1])
kNN_distance <- data.frame(kNN_data[2])
kNN_mean_distance <- rowMeans(kNN_distance)
## 3d density plot--------------------------------------
p <- source("plot_3d_with_denisity.R")
p
## Density group finding via "watershed/waterfilling"
# We go through all densities via the weightened kNN adjacency matrix
group_frame <- c(seq(1:header[1]))
number_of_groups <- length(unique(group_frame))
repeat{
for (current_i in seq(1:header[1])){
current_node <- group_frame[current_i]
# find current_nodes next possible greater radius node
index <- which(kNN_mean_distance[c(kNN_neighbors[current_node,],recursive = TRUE)] %in% max(kNN_mean_distance[c(kNN_neighbors[current_node,],recursive = TRUE)]))
next_node <- kNN_neighbors[current_node,index]
next_node_distance <- kNN_mean_distance[next_node]
# check wether lowest denisty neighbor is lower than the point itself
if (kNN_mean_distance[current_node] < kNN_mean_distance[next_node]) {
# update belonging list
group_frame[current_i] <- next_node
}
cat("index: ",current_i,"current node: ",current_node, " ",kNN_mean_distance[current_node],
" | note: ",c(kNN_neighbors[current_i,index],recursive = TRUE)," ", kNN_mean_distance[index],
" | next: ", group_frame[current_node] ,"\n")
}
cat("\n")
# If no new groups can be formed, we will break
tmp_groups <- number_of_groups
number_of_groups <- length(unique(group_frame))
if(number_of_groups ==  tmp_groups){
break
}
}
## 3d subvoid-group plot--------------------------------------
p <- source("plot_3d_with_groups.R")
p
# define what a void is---------------------------------------
# if the density in a subvoid is less then the average, subvoid will be declared as a not void
cell_frame = unique(group_frame)
data_per_cell = table(group_frame)
density_per_radius = kNN_mean_distance[cell_frame] / data_per_cell
void_index <- density_per_radius > mean(density_per_radius)
void_cells <- strtoi(rownames(void_index[which(void_index == TRUE)]))
data_cells <- strtoi(rownames(void_index[which(void_index == FALSE)]))
void_index <- which(group_frame %in% void_cells)
data_index <- which(group_frame %in% data_cells)
## 3d plot data frame with voids-------------------------------
p <- source("plot_3d_void.R")
p
x <- dataframe[void_index,]$V1
y <- dataframe[void_index,]$V2
z <- dataframe[void_index,]$V3
x_d <- dataframe[data_index,]$V1
y_d <- dataframe[data_index,]$V2
z_d <- dataframe[data_index,]$V3
p <-  plot_ly(x = ~x_d, y = ~y_d, z = ~z_d,type = "scatter3d") %>%
add_trace(x = ~x, y = ~y, z = ~z,type = "mesh3d")  %>%
layout(scene = list(xaxis = list(title = 'X',nticks = 20,range=c(0,1)),
yaxis = list(title = 'Y',nticks = 20,range=c(0,1)),
zaxis = list(title = 'Z',nticks = 20,range=c(0,1)),
aspectmode='cube'))
p
void_index <- density_per_radius > mean(density_per_radius)
void_cells <- strtoi(rownames(void_index[which(void_index == TRUE)]))
data_cells <- strtoi(rownames(void_index[which(void_index == FALSE)]))
void_index <- which(group_frame %in% void_cells)
data_index <- which(group_frame %in% data_cells)
x <- dataframe[void_index,]$V1
y <- dataframe[void_index,]$V2
z <- dataframe[void_index,]$V3
x_d <- dataframe[data_index,]$V1
y_d <- dataframe[data_index,]$V2
z_d <- dataframe[data_index,]$V3
p <- plot_ly(type = "scatter3d",mode = 'markers') %>%
add_markers(x = x_d,
y = y_d,
z = z_d,
text = data_index,
marker = list(color = 'rgb(0,0,0)',
size = 5),
showlegend = FALSE) %>%
add_markers(x = x,
y = y,
z = z,
text = void_index,
marker = list(size = kNN_mean_distance[void_index]*400,
color = group_frame[void_index],
opacity = 0.99,
colorscale = 'Rainbow',
showscale = TRUE),
showlegend = FALSE) %>%
layout(scene = list(xaxis = list(title = 'X',nticks = 20,range=c(0,1)),
yaxis = list(title = 'Y',nticks = 20,range=c(0,1)),
zaxis = list(title = 'Z',nticks = 20,range=c(0,1)),
aspectmode='cube'))
p
x <- dataframe$V1
y <- dataframe$V2
z <- dataframe$V3
p <- plot_ly(type = "scatter3d",mode = 'markers') %>%
add_markers(x = x,
y = y,
z = z,
text = seq(1:header[1]),
marker = list(color = 'rgb(0,0,0)',size = 5),
showlegend = FALSE) %>%
add_markers(x = x,
y = y,
z = z,
text = seq(1:header[1]),
marker = list(size = kNN_mean_distance*200,
color = kNN_mean_distance,
opacity = 0.99,
colorscale = "Rainbow",
showscale = TRUE),
showlegend = FALSE)%>%
layout(scene = list(xaxis = list(title = 'X',nticks = 20,range=c(0,1)),
yaxis = list(title = 'Y',nticks = 20,range=c(0,1)),
zaxis = list(title = 'Z',nticks = 20,range=c(0,1)),
aspectmode='cube'))
p
x <- dataframe$V1
y <- dataframe$V2
z <- dataframe$V3
p <- plot_ly(type = "scatter3d",mode = 'markers') %>%
add_markers(x = x,
y = y,
z = z,
text = seq(1:header[1]),
marker = list(color = 'rgb(0,0,0)',
size = 5),
showlegend = FALSE) %>%
add_markers(x = x,
y = y,
z = z,
text = seq(1:header[1]),
marker = list(size = kNN_mean_distance*250,
color = group_frame,
opacity = 0.99,
colorscale = 'Rainbow',
showscale = TRUE),
showlegend = FALSE)%>%
layout(scene = list(xaxis = list(title = 'X',nticks = 20,range=c(0,1)),
yaxis = list(title = 'Y',nticks = 20,range=c(0,1)),
zaxis = list(title = 'Z',nticks = 20,range=c(0,1)),
aspectmode='cube'))
p
mydataframe <- data.frame(mydataframe)
p <- plot_ly(mydataframe, x = mydataframe$X1  , y = mydataframe$X2 , z = mydataframe$X3) %>%
add_markers() %>%
layout(scene = list(xaxis = list(title = 'X',nticks = 20,range=c(0,1)),
yaxis = list(title = 'Y',nticks = 20,range=c(0,1)),
zaxis = list(title = 'Z',nticks = 20,range=c(0,1)),
aspectmode='cube'))
p
void_index <- density_per_radius > mean(density_per_radius)
void_cells <- strtoi(rownames(void_index[which(void_index == TRUE)]))
data_cells <- strtoi(rownames(void_index[which(void_index == FALSE)]))
void_index <- which(group_frame %in% void_cells)
data_index <- which(group_frame %in% data_cells)
x <- dataframe[void_index,]$V1
y <- dataframe[void_index,]$V2
z <- dataframe[void_index,]$V3
x_d <- dataframe[data_index,]$V1
y_d <- dataframe[data_index,]$V2
z_d <- dataframe[data_index,]$V3
p <- plot_ly(type = "scatter3d",mode = 'markers') %>%
add_markers(x = x_d,
y = y_d,
z = z_d,
text = data_index,
marker = list(color = 'rgb(0,0,0)',
size = 5),
showlegend = FALSE) %>%
add_markers(x = x,
y = y,
z = z,
text = void_index,
marker = list(size = kNN_mean_distance[void_index]*400,
color = group_frame[void_index],
opacity = 0.99,
colorscale = 'Rainbow',
showscale = TRUE),
showlegend = FALSE) %>%
layout(scene = list(xaxis = list(title = 'X',nticks = 20,range=c(0,1)),
yaxis = list(title = 'Y',nticks = 20,range=c(0,1)),
zaxis = list(title = 'Z',nticks = 20,range=c(0,1)),
aspectmode='cube'))
p
